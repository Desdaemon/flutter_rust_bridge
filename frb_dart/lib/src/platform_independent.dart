import 'dart:ffi';

import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'platform/platform.dart';
import 'package:meta/meta.dart';

/// Base class for various kinds of tasks.
/// Note: Normally you do not manually create instances of this task (or its brothers), but instead
/// it is generated automatically by the codegen.
@immutable
abstract class FlutterRustBridgeBaseTask {
  final FlutterRustBridgeTaskConstMeta constMeta;
  final List<dynamic> argValues;
  final dynamic hint;

  const FlutterRustBridgeBaseTask({
    required this.constMeta,
    required this.argValues,
    required this.hint,
  });

  String get debugName => constMeta.debugName;

  Iterable<MapEntry<String, dynamic>> get argMapEntries sync* {
    for (var i = 0; i < constMeta.argNames.length; ++i) {
      yield MapEntry(constMeta.argNames[i], argValues[i]);
    }
  }

  Map<String, dynamic> get argMap => Map.fromEntries(argMapEntries);
}

/// Metadata that does not change across different method calls. Thus it is made `const` to save memory and speed up
@immutable
class FlutterRustBridgeTaskConstMeta {
  final String debugName;
  final List<String> argNames;

  const FlutterRustBridgeTaskConstMeta({
    required this.debugName,
    required this.argNames,
  });
}

/// An exception that is generated by Rust code.
@immutable
class FfiException {
  final String code;
  final String message;
  final Object? details;

  FfiException(this.code, this.message, this.details);

  @override
  String toString() => 'FfiException($code, $message, $details)';
}

/// Exception when timeout happens using [FlutterRustBridgeTimeoutMixin]
class FlutterRustBridgeTimeoutException {
  /// The duration to trigger timeout
  final Duration duration;

  /// debugName of the task, usually the ffi function name
  final String debugName;

  /// The stack trace of the error
  final StackTrace stackTrace;

  FlutterRustBridgeTimeoutException(this.duration, this.debugName, this.stackTrace);

  @override
  String toString() =>
      'FlutterRustBridgeTimeoutException(debugName=$debugName,duration=$duration,stackTrace=$stackTrace)';
}

/// Describes a source for the dynamic library.
class LibraryMeta {
  /// Optional override for the dylib file.
  /// Not used by the iOS platform.
  final String? override;

  /// Whether to open a [DynamicLibrary.process] on native platforms instead.
  /// By default, [DynamicLibrary.executable] is used.
  final bool processDylib;

  const LibraryMeta({this.override, this.processDylib = false});
}

/// Describes the sources of dynamic libraries across platforms.
class LibrarySources {
  /// The base name of the library, usually your crate name. The derived library name will be:
  /// - `lib$base.so` on Android and Linux
  /// - `$base.dylib` on MacOS
  /// - `$base.dll` on Windows
  /// - `$base_bg.wasm` on WASM
  ///
  /// iOS must (and MacOS can) use linked binaries instead.
  final String base;
  final LibraryMeta android;
  final LibraryMeta ios;
  final LibraryMeta macos;
  final LibraryMeta linux;
  final LibraryMeta windows;
  final LibraryMeta web;

  const LibrarySources(
    this.base, {
    this.android = const LibraryMeta(),
    this.ios = const LibraryMeta(),
    this.macos = const LibraryMeta(),
    this.linux = const LibraryMeta(),
    this.windows = const LibraryMeta(),
    this.web = const LibraryMeta(),
  });

  String get libraryName {
    switch (currentPlatform) {
      case 'js':
        return web.override ?? '${base}_bg.wasm';
      case 'windows':
        return windows.override ?? '$base.dll';
      case 'macos':
        return macos.override ?? '$base.dylib';
      default:
        return linux.override ?? 'lib$base.so';
    }
  }
}
